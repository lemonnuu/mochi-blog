import{_ as e,c as t,e as l,w as p,d as s,b as n,a as o,r as c,o as r}from"./app.e0b3b0bc.js";const _=JSON.parse('{"title":"TypeScript","titleTemplate":"接口","description":"","frontmatter":{"title":"TypeScript","titleTemplate":"接口"},"headers":[{"level":2,"title":"普通对象","slug":"普通对象","link":"#普通对象","children":[{"level":3,"title":"额外的属性检查","slug":"额外的属性检查","link":"#额外的属性检查","children":[]},{"level":3,"title":"可选属性","slug":"可选属性","link":"#可选属性","children":[]},{"level":3,"title":"只读属性","slug":"只读属性","link":"#只读属性","children":[]},{"level":3,"title":"索引签名","slug":"索引签名","link":"#索引签名","children":[]}]},{"level":2,"title":"接口继承","slug":"接口继承","link":"#接口继承","children":[]},{"level":2,"title":"接口合并","slug":"接口合并","link":"#接口合并","children":[]},{"level":2,"title":"函数","slug":"函数","link":"#函数","children":[{"level":3,"title":"带有属性的函数定义","slug":"带有属性的函数定义","link":"#带有属性的函数定义","children":[]},{"level":3,"title":"构造函数定义","slug":"构造函数定义","link":"#构造函数定义","children":[]}]},{"level":2,"title":"类","slug":"类","link":"#类","children":[{"level":3,"title":"类实现接口","slug":"类实现接口","link":"#类实现接口","children":[]},{"level":3,"title":"接口继承自类","slug":"接口继承自类","link":"#接口继承自类","children":[]}]},{"level":2,"title":"接口 VS 类型别名","slug":"接口-vs-类型别名","link":"#接口-vs-类型别名","children":[]}],"relativePath":"_NOTES/TypeScript/basic/003_interface.md","lastUpdated":1679119704000}'),y={name:"_NOTES/TypeScript/basic/003_interface.md"},C=n("h1",{id:"接口",tabindex:"-1"},[s("接口 "),n("a",{class:"header-anchor",href:"#接口","aria-hidden":"true"},"#")],-1),D=n("p",null,'TypeScript 的核心原则之一是对值所具有的结构进行类型检查, 它有时被称做"鸭式辨型法"或"结构性子类型化"。',-1),F=o("",8),A=o("",38),i=o("",2),d=o("",9);function B(u,h,g,m,b,E){const a=c("f");return r(),t("div",null,[C,D,l(a,null,{default:p(()=>[s("接口能够描述 JavaScript 中对象拥有的各种各样的外形")]),_:1}),s("。除了描述带有属性的普通对象外, 接口也可以描述函数类型, 还可以被类实现与继承自类。"),F,n("p",null,[s("在继续深入之前, 有一点需要特别注意, "),l(a,null,{default:p(()=>[s("对象字面量会被特殊对待, 从而进行额外的属性检查")]),_:1}),s('。当将它们赋值给变量或作为参数传递的时候, 如果一个对象字面量存在任何"目标类型"不包含的属性时, 就会得到一个错误。')]),A,n("p",null,[s("但需要注意的是, "),l(a,null,{default:p(()=>[s("接口只描述了类的公共部分, 并不包含私有或保护成员")]),_:1}),s("。")]),i,l(a,null,{default:p(()=>[s("当一个类实现了一个接口时, 只会对其实例部分进行类型检查")]),_:1}),s(", 诸如 constructor、static 等静态部分并不在检查范围内。"),d])}const v=e(y,[["render",B]]);export{_ as __pageData,v as default};
