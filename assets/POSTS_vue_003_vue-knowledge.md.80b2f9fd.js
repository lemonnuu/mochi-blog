import{_ as e,c as l,o as i,a as t}from"./app.eb5321dd.js";const h=JSON.parse('{"title":"Vue知识串记","titleTemplate":false,"description":"","frontmatter":{"date":"2023-02-26 09:26:20","title":"Vue知识串记","titleTemplate":false,"author":"Mochi","outline":[2,4],"categories":["post"],"tags":["vue"]},"headers":[{"level":2,"title":"Vue Router","slug":"vue-router","link":"#vue-router","children":[]},{"level":2,"title":"路线","slug":"路线","link":"#路线","children":[]}],"relativePath":"_POSTS/vue/003_vue-knowledge.md","lastUpdated":1679119704000}'),o={name:"_POSTS/vue/003_vue-knowledge.md"},a=t('<h1 id="vue-知识串记" tabindex="-1">Vue 知识串记 <a class="header-anchor" href="#vue-知识串记" aria-hidden="true">#</a></h1><ol><li>Vue 的核心</li></ol><ul><li>声明式渲染</li><li>响应性</li></ul><ol start="2"><li>API 风格: 选项式、组合式</li><li>初始化 Vue3 项目: <code>npm init vue@latest</code>, 会执行 create-vue</li><li>Vue 相关性能优化 <ul><li><a href="https://web.dev/fast/" target="_blank" rel="noreferrer">web.dev 指南</a>(无关框架的优化)</li><li>页面加载优化 <ul><li>正确的架构: SPA、SSG、SSR</li><li>tree shaking</li><li>code-spliting 懒加载</li></ul></li><li>更新优化 <ul><li>保持 prop 的稳定性</li><li>v-once</li><li>v-memo</li></ul></li><li>通用优化 <ul><li>虚拟列表</li><li>减少大型不可变数据的响应性开销</li><li>避免不必要的组件抽象</li></ul></li></ul></li><li>DOM 的更新并不是同步的</li><li>ref 的自动解包 <ul><li>模板中作为顶层属性被访问时</li><li>reactive 对象的属性被访问时, 但 reactive 数组或 Map 的项不会</li></ul></li><li>computed 返回一个 computedRefImpl 实例, 会有缓存, 不应有任何副作用</li><li>Vue 3 的 &lt;template&gt; 如果上面没有 v-if、v-for 会真实渲染成 &lt;template&gt; 标签, Vue2 不会</li><li>v-if 和 v-show 的区别就是 v-if 是真正的移除增加 DOM, 而 v-show 是通过 CSS 的 display 来控制显示与隐藏的</li><li>不推荐同一元素上使用 v-if 和 v-for, 但是如果用了, Vue3 的 v-if 优先级更高, Vue2 的 v-for 优先级高</li><li>key 管理状态, 要合理使用 key 属性</li><li>生命周期 <ul><li>setup</li><li>beforeCreate</li><li>created</li><li>beforeMount</li><li>mounted</li><li>beforeUpdate</li><li>updated</li><li>beforeUnmount(Vue2: beforeDestroy)</li><li>unmounted (Vue2: destroyed)</li></ul></li><li>模板引用: 同名的 ref, 也可以是一个函数, v-for 的时候还可以是一个数组</li><li>SFC 单文件组件规范组件建议使用 PascalCase 名称</li><li>常用: <ul><li><code>setup(props, {attrs, slots, emit, expose})</code></li><li><code>const props = defineProps()</code></li><li><code>const emit = defineEmits()</code></li><li><code>const attrs = useAttrs()</code></li></ul></li><li>Vue 遵从单向数据流</li><li>事件的校验可传入一个对象, 事件可以被赋值为一个函数</li><li><code>$attrs</code> 保留原始名, 然后事件前面加 <code>on</code>, 如 <code>onClick</code></li><li>插件本质上就是一个拥有 install 方法的对象或函数, install 方法的第一个参数是 app, 第二个参数是传递给 app.use() 方法的额外参数 options</li><li>自定义指令: <code>const vFocus = {...}</code></li></ol><h2 id="vue-router" tabindex="-1">Vue Router <a class="header-anchor" href="#vue-router" aria-hidden="true">#</a></h2><ol><li>模式: History、Hash、Memory (手写一下原理)</li><li>和 keep-alive 结合</li><li>路由守卫、结合 元数据, 比如做一些鉴权</li><li>VueRouter4 新增的动态路由, 也就是可以增加或者是删除一些路由</li></ol><p><a href="https://segmentfault.com/a/1190000037540533" target="_blank" rel="noreferrer">https://segmentfault.com/a/1190000037540533</a></p><h2 id="路线" tabindex="-1">路线 <a class="header-anchor" href="#路线" aria-hidden="true">#</a></h2><p>VueRouter -&gt; Vuex -&gt; Pinia -&gt; Vue TypeScript -&gt; 算法 CSS -&gt; HTTP -&gt; JS</p>',9),r=[a];function u(s,d,c,n,p,f){return i(),l("div",null,r)}const _=e(o,[["render",u]]);export{h as __pageData,_ as default};
