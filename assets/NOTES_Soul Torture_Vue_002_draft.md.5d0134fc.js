import{_ as i,c as d,b as e,d as l,t as a,a as t,o as u}from"./app.e0b3b0bc.js";const $=JSON.parse('{"title":"Vue 相关(待整理)","description":"","frontmatter":{},"headers":[{"level":2,"title":"Vue 的核心是什么","slug":"vue-的核心是什么","link":"#vue-的核心是什么","children":[]},{"level":2,"title":"请简述你对 vue 的理解","slug":"请简述你对-vue-的理解","link":"#请简述你对-vue-的理解","children":[]},{"level":2,"title":"请简述 vue 的单向数据流","slug":"请简述-vue-的单向数据流","link":"#请简述-vue-的单向数据流","children":[]},{"level":2,"title":"Vue 常用的修饰符有哪些","slug":"vue-常用的修饰符有哪些","link":"#vue-常用的修饰符有哪些","children":[]},{"level":2,"title":"v-text 与 {{}} 与 v-html 区别","slug":"v-text-与-与-v-html-区别","link":"#v-text-与-与-v-html-区别","children":[]},{"level":2,"title":"v-on 可以绑定多个方法吗","slug":"v-on-可以绑定多个方法吗","link":"#v-on-可以绑定多个方法吗","children":[]},{"level":2,"title":"Vue 循环的 key 作用","slug":"vue-循环的-key-作用","link":"#vue-循环的-key-作用","children":[]},{"level":2,"title":"Vue 单页面应用(SPA)的优缺点","slug":"vue-单页面应用-spa-的优缺点","link":"#vue-单页面应用-spa-的优缺点","children":[]},{"level":2,"title":"Vuex 是什么？ 怎么使用？ 在那种场景下使用","slug":"vuex-是什么-怎么使用-在那种场景下使用","link":"#vuex-是什么-怎么使用-在那种场景下使用","children":[]},{"level":2,"title":"Vue 中路由跳转方式（声明式/编程式）","slug":"vue-中路由跳转方式-声明式-编程式","link":"#vue-中路由跳转方式-声明式-编程式","children":[]},{"level":2,"title":"vue 跨域的解决方式","slug":"vue-跨域的解决方式","link":"#vue-跨域的解决方式","children":[]},{"level":2,"title":"Vue 的生命周期请简述","slug":"vue-的生命周期请简述","link":"#vue-的生命周期请简述","children":[]},{"level":2,"title":"Vue 生命周期的作用","slug":"vue-生命周期的作用","link":"#vue-生命周期的作用","children":[]},{"level":2,"title":"DOM 渲染在那个生命周期阶段内完成","slug":"dom-渲染在那个生命周期阶段内完成","link":"#dom-渲染在那个生命周期阶段内完成","children":[]},{"level":2,"title":"Vue 路由的实现","slug":"vue-路由的实现","link":"#vue-路由的实现","children":[]},{"level":2,"title":"Vue 路由模式 hash 和 history, 简单讲一下","slug":"vue-路由模式-hash-和-history-简单讲一下","link":"#vue-路由模式-hash-和-history-简单讲一下","children":[]},{"level":2,"title":"Vue 路由传参的两种方式, params 和 query","slug":"vue-路由传参的两种方式-params-和-query","link":"#vue-路由传参的两种方式-params-和-query","children":[]},{"level":2,"title":"Vue 的路由钩子函数/路由守卫有哪些","slug":"vue-的路由钩子函数-路由守卫有哪些","link":"#vue-的路由钩子函数-路由守卫有哪些","children":[]},{"level":2,"title":"Vue 中如何进行动态路由设置？ 有哪些方式？ 怎么获取传递过来的数据？","slug":"vue-中如何进行动态路由设置-有哪些方式-怎么获取传递过来的数据","link":"#vue-中如何进行动态路由设置-有哪些方式-怎么获取传递过来的数据","children":[]},{"level":2,"title":"如何让组件中的 css 在当前组件生效","slug":"如何让组件中的-css-在当前组件生效","link":"#如何让组件中的-css-在当前组件生效","children":[]},{"level":2,"title":"Mvvm 与 mvc 的区别","slug":"mvvm-与-mvc-的区别","link":"#mvvm-与-mvc-的区别","children":[]},{"level":2,"title":"Vue 组件中的 data 为什么是函数","slug":"vue-组件中的-data-为什么是函数","link":"#vue-组件中的-data-为什么是函数","children":[]}],"relativePath":"_NOTES/Soul Torture/Vue/002_draft.md","lastUpdated":1677068989000}'),r={name:"_NOTES/Soul Torture/Vue/002_draft.md"},o=t('<h1 id="vue-相关-待整理" tabindex="-1">Vue 相关(待整理) <a class="header-anchor" href="#vue-相关-待整理" aria-hidden="true">#</a></h1><h2 id="vue-的核心是什么" tabindex="-1">Vue 的核心是什么 <a class="header-anchor" href="#vue-的核心是什么" aria-hidden="true">#</a></h2><p>Vue 是一套构建用户界面的渐进式自底向上增量开发的 MVVM 框架, vue 的核心只关注视图层。</p><p>核心思想:</p><ul><li>数据驱动（视图的内容随着数据的改变而改变）</li><li>组件化（可以增加代码的复用性, 可维护性, 可测试性, 提高开发效率, 方便重复使用, 体现了高内聚低耦合）</li></ul><h2 id="请简述你对-vue-的理解" tabindex="-1">请简述你对 vue 的理解 <a class="header-anchor" href="#请简述你对-vue-的理解" aria-hidden="true">#</a></h2><p>Vue 是一套构建用户界面的渐进式的自底向上增量开发的 MVVM 框架, 核心是关注视图层, vue 的核心是为了解决数据的绑定问题, 为了开发大 型单页面应用和组件化, 所以 vue 的核心思想是数据驱动和组件化。这里也说一下 MVVM 思想, MVVM 思想是 模型——视图 vm 是 v 和 m 连 接的桥梁, 当模型层数据修改时, VM 层会检测到, 并通知视图层进行相应修改。</p><h2 id="请简述-vue-的单向数据流" tabindex="-1">请简述 vue 的单向数据流 <a class="header-anchor" href="#请简述-vue-的单向数据流" aria-hidden="true">#</a></h2><p>父级 prop 的更新会向下流动到子组件中, 每次父组件发生更新, 子组件所有的 prop 都会刷新为最新的值, 数据从父组件传递给子组件, 只能单向绑定, 子组件内部不能直接修改。</p><h2 id="vue-常用的修饰符有哪些" tabindex="-1">Vue 常用的修饰符有哪些 <a class="header-anchor" href="#vue-常用的修饰符有哪些" aria-hidden="true">#</a></h2><p>修饰符:</p><ul><li><code>.lazy</code> : 改变后触发, 光标离开 input 输入框的时候值才会改变</li><li><code>.number</code> : 将输出字符串转为 number 类型</li><li><code>.trim</code> 自动过滤用户输入的首尾空格</li></ul><p>事件修饰符:</p><ul><li><code>.stop</code> 阻止点击事件冒泡, 相当于原生 js 中的 <code>event.stopPropagation()</code></li><li><code>.prevent</code> 防止执行预设的行为, 相当于原生 js 中的 <code>event.preventDefault()</code></li><li><code>.capture</code> 添加事件侦听器时使用事件捕获模式</li><li><code>.self</code> 只会触发自己范围内的事件, 不包括子元素</li><li><code>.once</code> 只执行一次</li></ul><p>键盘修饰符:</p><ul><li><code>.enter</code> 回车键</li><li><code>.tab</code> 制表键</li><li><code>.esc</code> 返回键</li><li><code>.space</code> 空格键</li><li><code>.up</code>向上键</li><li><code>.down</code> 向下键</li><li><code>.left</code> 向左建</li><li><code>.right</code> 向右键 系统修饰符：<code>.ctrl</code> <code>.alt</code> <code>.shift</code> <code>.meta</code></li></ul>',16),h={id:"v-text-与-与-v-html-区别",tabindex:"-1"},c=e("code",null,"v-text",-1),s=e("code",null,"v-html",-1),n=e("a",{class:"header-anchor",href:"#v-text-与-与-v-html-区别","aria-hidden":"true"},"#",-1),v=e("li",null,[e("code",null,"v-html"),l(" 可以渲染输出 html")],-1),p=e("li",null,[e("code",null,"v-text"),l(" 将数据解析为纯文本, 不能输出真正的 html, 与花括号的区别是在页面加载时不显示双花括号")],-1),m=e("code",null,"v-text",-1),_=e("code",null,"v-text",-1),x=e("code",null,"v-text",-1),V=e("code",null,"v-text",-1),f=t('<h2 id="v-on-可以绑定多个方法吗" tabindex="-1">v-on 可以绑定多个方法吗 <a class="header-anchor" href="#v-on-可以绑定多个方法吗" aria-hidden="true">#</a></h2><p>可以, 如果绑定多个事件, 可以用键值对的形式(对象形式)。如果绑定是多个相同事件, 直接用逗号分隔就行</p><h2 id="vue-循环的-key-作用" tabindex="-1">Vue 循环的 key 作用 <a class="header-anchor" href="#vue-循环的-key-作用" aria-hidden="true">#</a></h2><p>Key 值的存在保证了唯一性, Vue 在执行时, 会对节点进行检查, 如果没有 key 值, 那么 vue 检查到这里有 dom 节点, 就会对内容清空并赋 新值, 如果有 key 值存在, 那么会对新老节点进行对比, 比较两者 key 是否相同, 进行调换位置或删除操作</p><h2 id="vue-单页面应用-spa-的优缺点" tabindex="-1">Vue 单页面应用(SPA)的优缺点 <a class="header-anchor" href="#vue-单页面应用-spa-的优缺点" aria-hidden="true">#</a></h2><ul><li>优点：前后端分离 用户体验好 一个字 快 内容改变不需要重新加载整个页面</li><li>缺点：不利于 SEO, 初次加载时耗长（浏览器一开始就要加载 html、css、js , 所有的页面内容都包含在主页面中）, 页面复杂度提高了, 导航不可用</li></ul><h2 id="vuex-是什么-怎么使用-在那种场景下使用" tabindex="-1">Vuex 是什么？ 怎么使用？ 在那种场景下使用 <a class="header-anchor" href="#vuex-是什么-怎么使用-在那种场景下使用" aria-hidden="true">#</a></h2><p>Vuex 是一个专为 vue.js 应用程序开发的状态管理模式, 通过创建一个集中的数据存储, 方便程序中的所有组件进行访问, 简单来说 vuex 就是 vue 的状态管理工具。</p><p>Vuex 有五个属性: state、getters、mutations、actions、modules。</p><p>State 就是数据源存放地, 对应一般 vue 对象的 data, state 里面存放的数据是响应式的, state 数据发生改变, 对应这个数据的组件也会发生改 变 用 <code>this.$store.state.xxx</code> 调用。</p><p>Getters 相当于 store 的计算属性, 主要是对 state 中数据的过滤, 用 <code>this.$store.getters.xxx</code> 调用</p><p>Mutations 处理数据逻辑的方法全部放在 mutations 中, 当触发事件想改变 state 数据的时候使用 mutations, 用 <code>this.$store.commit</code> 调用, 给这个方法添加一个参数, 就是 mutation 的载荷（payload）</p><p>Actions 异步操作数据 , 但是是通过 mutation 来更新 State, 用 <code>this.$store.dispatch</code> 来触发, actions 也支持载荷</p><p>使用场景：组件之间的状态, 登录状态, 加入购物车, 音乐播放</p><h2 id="vue-中路由跳转方式-声明式-编程式" tabindex="-1">Vue 中路由跳转方式（声明式/编程式） <a class="header-anchor" href="#vue-中路由跳转方式-声明式-编程式" aria-hidden="true">#</a></h2><p>Vue 中路由跳转有两种, 分别是声明式和编程式</p><ul><li>用 js 方式进行跳转的叫编程式导航 <code>this.$router.push()</code></li><li>用 <code>router-link</code> 进行跳转的叫声明式 <code>router-view</code> 路由出口, 路由模板显示的位置</li></ul><p>路由中 name 属性有什么作用？ 在 router-link 中使用 name 导航到对应路由使用 name 导航的同时, 给子路由传递参数</p><h2 id="vue-跨域的解决方式" tabindex="-1">vue 跨域的解决方式 <a class="header-anchor" href="#vue-跨域的解决方式" aria-hidden="true">#</a></h2><ol><li>后台更改 header (CORS)</li><li>使用 jq 提供 jsonp 3.用 http-proxy-middleware（配置代理服务器的中间件）</li></ol><h2 id="vue-的生命周期请简述" tabindex="-1">Vue 的生命周期请简述 <a class="header-anchor" href="#vue-的生命周期请简述" aria-hidden="true">#</a></h2><p>vue 的生命周期就是 vue 实例创建到实例销毁的过程。期间会有 8 个钩子函数的调用。</p><ul><li>beforeCreate（创建实例）</li><li>created（创建完成）、</li><li>beforeMount（开始创建模板）</li><li>mounted（创建完成）、</li><li>beforeUpdate（开始更新）</li><li>updated（更新完成）、</li><li>beforeDestroy（开始销毁）</li><li>destroyed（销毁完成）</li></ul><h2 id="vue-生命周期的作用" tabindex="-1">Vue 生命周期的作用 <a class="header-anchor" href="#vue-生命周期的作用" aria-hidden="true">#</a></h2><p>给了用户在不同阶段添加自己的代码的机会</p><h2 id="dom-渲染在那个生命周期阶段内完成" tabindex="-1">DOM 渲染在那个生命周期阶段内完成 <a class="header-anchor" href="#dom-渲染在那个生命周期阶段内完成" aria-hidden="true">#</a></h2><p>DOM 渲染在 mounted 周期中就已经完成</p><h2 id="vue-路由的实现" tabindex="-1">Vue 路由的实现 <a class="header-anchor" href="#vue-路由的实现" aria-hidden="true">#</a></h2><p>前端路由就是更新视图但不请求页面, 利用锚点完成切换, 页面不会刷新</p><h2 id="vue-路由模式-hash-和-history-简单讲一下" tabindex="-1">Vue 路由模式 hash 和 history, 简单讲一下 <a class="header-anchor" href="#vue-路由模式-hash-和-history-简单讲一下" aria-hidden="true">#</a></h2><ul><li>Hash 模式地址栏中有<code>#</code>, history 没有,</li><li>history 模式下刷新, 会出现 404 情况, 需要后台配置</li></ul><p>使用 JavaScript 来对 loaction.hash 进行赋值, 改变 URL 的 hash 值, 可以使用 hashchange 事件来监听 hash 值的变化。</p><p>HTML5 提供了 History API 来实现 URL 的变化。其中最主要的 API 有以下两个：</p><ul><li><code>history.pushState()</code></li><li><code>history.repalceState()</code></li></ul><p>这两个 API 可以在不进行刷新的情况下, 操作浏览器的历史纪录。唯一不同的是, 前者是新增一个历史记录, 后者是直接替换当前的历史记录。</p><h2 id="vue-路由传参的两种方式-params-和-query" tabindex="-1">Vue 路由传参的两种方式, params 和 query <a class="header-anchor" href="#vue-路由传参的两种方式-params-和-query" aria-hidden="true">#</a></h2><p>方式与区别:</p><p>动态路由也可以叫路由传参, 就是根据不同的选择在同一个组件渲染不同的内容</p><p>用法上：query 用 path 引入, params 用 name 引入, 接收参数都是类似的, 分别是 <code>this.$route.query.name</code> 和 <code>this.$route.params.name</code></p><p>url 展示上:</p><ul><li>params 类似于 post, query 类似于 get, 也就是安全问题, params 传值相对更安全点, query 通过 url 传参, 刷新页面还在, params 刷新页面不在了</li></ul><h2 id="vue-的路由钩子函数-路由守卫有哪些" tabindex="-1">Vue 的路由钩子函数/路由守卫有哪些 <a class="header-anchor" href="#vue-的路由钩子函数-路由守卫有哪些" aria-hidden="true">#</a></h2><p>全局守卫：<code>beforeEach</code>（to, from, next）和 <code>afterEach</code>（to, from）</p><p>路由独享守卫：<code>beforeEnter</code></p><p>组件内的守卫 ： 路由进入/ 更 新 / 离开之前 : beforeRouterEnter/update/leave</p><h2 id="vue-中如何进行动态路由设置-有哪些方式-怎么获取传递过来的数据" tabindex="-1">Vue 中如何进行动态路由设置？ 有哪些方式？ 怎么获取传递过来的数据？ <a class="header-anchor" href="#vue-中如何进行动态路由设置-有哪些方式-怎么获取传递过来的数据" aria-hidden="true">#</a></h2><p>动态路由也可以叫路由传参, 动态路由有 query 和 prrams 两种方式传参</p><p>query 用 path 引 入 , params 用 name 引 入 , query 用 <code>this.$route.query.name</code> 接收参数, params 用 <code>this.$route.params.name</code> 接收参数</p><h2 id="如何让组件中的-css-在当前组件生效" tabindex="-1">如何让组件中的 css 在当前组件生效 <a class="header-anchor" href="#如何让组件中的-css-在当前组件生效" aria-hidden="true">#</a></h2><ul><li>在 styled 中加上 <code>scoped</code></li><li>还有 CSS module</li></ul><h2 id="mvvm-与-mvc-的区别" tabindex="-1">Mvvm 与 mvc 的区别 <a class="header-anchor" href="#mvvm-与-mvc-的区别" aria-hidden="true">#</a></h2><p>Mvc 模型视图控制器, 视图是可以直接访问模型, 所以, 视图里面会包含模型信息, mvc 关注的是模型不变, 所以, 在 mvc 中, 模型不依赖视 图, 但是视图依赖模型 Mvvm 模型 视图 和 vm vm 是作为模型和视图的桥梁, 当模型层数据改变, vm 会检测到并通知视图层进行相应的修改</p><h2 id="vue-组件中的-data-为什么是函数" tabindex="-1">Vue 组件中的 data 为什么是函数 <a class="header-anchor" href="#vue-组件中的-data-为什么是函数" aria-hidden="true">#</a></h2><p>Data 是一个函数时, 每个组件实例都有自己的作用域, 每个实例相互独立, 不会相互影响</p><p>如果是引用类型（对象）, 当多个组件共用一个数据源时, 一处数据改变, 所有的组件数据都会改变, 所以要利用函数通过 return 返回对象的拷贝, （返回一个新数据）, 让每个实例都有自己的作用域, 相互不影响。</p>',55);function y(k,b,g,S,M,T){return u(),d("div",null,[o,e("h2",h,[c,l(" 与 "),e("code",null,a(),1),l(" 与 "),s,l(" 区别 "),n]),e("ul",null,[e("li",null,[e("code",null,a(),1),l(" 将数据解析为纯文本, 不能显示输出 html")]),v,p]),e("p",null,[m,l(" 指令作用：操作网页元素中的纯文本内容, "),e("code",null,a(),1),l("是他的另外一种写法。")]),e("p",null,[_,l(" 与 "),e("code",null,a(),1),l(" 区别：")]),e("p",null,[x,l(" 与"),e("code",null,a(),1),l("等价, "),e("code",null,a(),1),l("叫模板插值, "),V,l(" 叫指令。有一点区别就是, 在渲染的数据比较多的时候, 可能会把大括号显示出 来, 俗称屏幕闪动。")]),f])}const A=i(r,[["render",y]]);export{$ as __pageData,A as default};
