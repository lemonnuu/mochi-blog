import{_ as e,c as l,o as i,a as t}from"./app.eb5321dd.js";const m=JSON.parse('{"title":"Vue 基础","description":"","frontmatter":{},"headers":[{"level":2,"title":"watch 和 computed 的区别?","slug":"watch-和-computed-的区别","link":"#watch-和-computed-的区别","children":[]},{"level":2,"title":"Vue 组件通讯有几种方式?","slug":"vue-组件通讯有几种方式","link":"#vue-组件通讯有几种方式","children":[]},{"level":2,"title":"Vuex mutation 与 action 的区别","slug":"vuex-mutation-与-action-的区别","link":"#vuex-mutation-与-action-的区别","children":[]},{"level":2,"title":"虚拟 DOM (VDOM) 真的很快嘛?","slug":"虚拟-dom-vdom-真的很快嘛","link":"#虚拟-dom-vdom-真的很快嘛","children":[]},{"level":2,"title":"keep-alive 组件有什么作用?","slug":"keep-alive-组件有什么作用","link":"#keep-alive-组件有什么作用","children":[]},{"level":2,"title":"为何 ref 需要 value 属性?","slug":"为何-ref-需要-value-属性","link":"#为何-ref-需要-value-属性","children":[]}],"relativePath":"_NOTES/Soul Torture/Vue/001_basic.md","lastUpdated":1677068989000}'),a={name:"_NOTES/Soul Torture/Vue/001_basic.md"},c=t('<h1 id="vue-基础" tabindex="-1">Vue 基础 <a class="header-anchor" href="#vue-基础" aria-hidden="true">#</a></h1><nav class="table-of-contents"><ul><li><a href="#watch-和-computed-的区别">watch 和 computed 的区别?</a></li><li><a href="#vue-组件通讯有几种方式">Vue 组件通讯有几种方式?</a></li><li><a href="#vuex-mutation-与-action-的区别">Vuex mutation 与 action 的区别</a></li><li><a href="#虚拟-dom-vdom-真的很快嘛">虚拟 DOM (VDOM) 真的很快嘛?</a></li><li><a href="#keep-alive-组件有什么作用">keep-alive 组件有什么作用?</a></li><li><a href="#为何-ref-需要-value-属性">为何 ref 需要 value 属性?</a></li></ul></nav><div class="danger custom-block"><p class="custom-block-title">Vue 面试题文章</p><ul><li><a href="https://juejin.cn/post/7097067108663558151" target="_blank" rel="noreferrer">https://juejin.cn/post/7097067108663558151</a></li><li><a href="https://juejin.cn/post/6961222829979697165" target="_blank" rel="noreferrer">https://juejin.cn/post/6961222829979697165</a></li></ul></div><h2 id="watch-和-computed-的区别" tabindex="-1">watch 和 computed 的区别? <a class="header-anchor" href="#watch-和-computed-的区别" aria-hidden="true">#</a></h2><div class="info custom-block"><p class="custom-block-title">吐槽</p><p>不能说一模一样, 只能说毫不相关。</p></div><div class="tip custom-block"><p class="custom-block-title">答案</p><ul><li>computed 用于计算产出新的数据, 有缓存</li><li>watch 用于监听现有数据执行某些副作用</li></ul></div><h2 id="vue-组件通讯有几种方式" tabindex="-1">Vue 组件通讯有几种方式? <a class="header-anchor" href="#vue-组件通讯有几种方式" aria-hidden="true">#</a></h2><div class="tip custom-block"><p class="custom-block-title">答案</p><ul><li>props 和 emit</li><li>自定义事件 (事件总线)</li><li>$attrs</li><li>$parent</li><li>$refs</li><li>provide / inject</li><li>Vuex</li></ul></div><h2 id="vuex-mutation-与-action-的区别" tabindex="-1">Vuex mutation 与 action 的区别 <a class="header-anchor" href="#vuex-mutation-与-action-的区别" aria-hidden="true">#</a></h2><div class="tip custom-block"><p class="custom-block-title">答案</p><ul><li>mutaion : 原子操作, 必须同步代码</li><li>action : 可包含多个 mutation, 可包含异步代码</li></ul></div><h2 id="虚拟-dom-vdom-真的很快嘛" tabindex="-1">虚拟 DOM (VDOM) 真的很快嘛? <a class="header-anchor" href="#虚拟-dom-vdom-真的很快嘛" aria-hidden="true">#</a></h2><div class="info custom-block"><p class="custom-block-title">前情提要</p><p>VDOM : 用 JS 对象模拟的 DOM 节点数据</p></div><div class="tip custom-block"><p class="custom-block-title">答案</p><ul><li>VDOM 并不快, JS 直接操作 DOM 才是最快的</li><li>但 &quot;数据驱动视图&quot; 要有合适的技术方案, 不能全部 DOM 重建</li><li>VDOM 就是目前最合适的技术方案(并不是因为它快, 而是合适)</li></ul></div><h2 id="keep-alive-组件有什么作用" tabindex="-1">keep-alive 组件有什么作用? <a class="header-anchor" href="#keep-alive-组件有什么作用" aria-hidden="true">#</a></h2><div class="info custom-block"><p class="custom-block-title">前置知识</p><p>一般情况下, 组件进行切换的时候, 默认是会进行销毁的, 如果我们有需求, 在某个组件切换后不进行销毁, 而是保存之前的状态, 那么就可以利用 keep-alive 来实现。</p><p>在 keep-alive 上有两个属性, 可以对字符串或正则表达式进行匹配, 匹配到的组件会被缓存。</p><ul><li>include 值为字符串或者正则表达式匹配的组件 name 会被缓存 (缓存匹配到的组件)</li><li>exclude 值为字符串或正则表达式匹配的组件 name 不会被缓存 (排除匹配到的组件)</li></ul><p>其拥有两个独立的生命周期钩子函数 actived 和 deactived, 使用 keep-alive 包裹的组件在切换时不会被销毁, 而是缓存到内存中并执行 deactived 钩子函数, 命中缓存渲染后会执行 actived 钩子函数。</p></div><div class="tip custom-block"><p class="custom-block-title">答案</p><p>keep-alive 是 vue 的内置组件, 而这个组件的作用就是能够缓存不活动的组件。</p></div><h2 id="为何-ref-需要-value-属性" tabindex="-1">为何 ref 需要 value 属性? <a class="header-anchor" href="#为何-ref-需要-value-属性" aria-hidden="true">#</a></h2><div class="tip custom-block"><p class="custom-block-title">答案</p><p>ref 需要借助 value 属性实现原始数据类型的响应性。</p></div><div class="info custom-block"><p class="custom-block-title">解析</p><ul><li>首先 Vue3 实现响应式数据的核心 API 是 Proxy, 故而有了 reactive 函数用于创建响应式对象</li><li>但是 Proxy 只能代理对象, 诸如 string、number 等原始类型处理不了</li><li>所以 Vue3 有了 ref 函数用于创建原始类型的响应式数据</li><li>它的本质是生成了一个 RefImpl 实例, 通过 value 属性的 getter 和 setter 实现响应性</li><li>当 ref 参数为对象时, 其 value 值还是基于 reactive 函数进行处理</li><li>当 ref 参数为原始数据类型时, value 的 getter 收集依赖, setter 主动触发依赖</li><li>所以 ref 需要借助 value 属性实现原始数据类型的响应性</li></ul></div>',19),o=[c];function s(u,r,d,n,p,v){return i(),l("div",null,o)}const f=e(a,[["render",s]]);export{m as __pageData,f as default};
