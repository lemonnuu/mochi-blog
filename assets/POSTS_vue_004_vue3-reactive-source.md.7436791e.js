import{_ as s,c as a,o as l,a as n}from"./app.53870d29.js";const A=JSON.parse('{"title":"Vue3 响应性原理","titleTemplate":false,"description":"","frontmatter":{"date":"2023-02-16 10:31:34","title":"Vue3 响应性原理","titleTemplate":false,"author":"Mochi","outline":[2,4],"categories":["post"],"tags":["vue"]},"headers":[{"level":2,"title":"笔记","slug":"笔记","link":"#笔记","children":[]},{"level":2,"title":"ref","slug":"ref","link":"#ref","children":[]}],"relativePath":"_POSTS/vue/004_vue3-reactive-source.md","lastUpdated":1676556196000}'),e={name:"_POSTS/vue/004_vue3-reactive-source.md"},p=n(`<h1 id="vue3-响应性原理" tabindex="-1">Vue3 响应性原理 <a class="header-anchor" href="#vue3-响应性原理" aria-hidden="true">#</a></h1><p>所谓的响应性其实指的就是: 当响应式数据触发 setter 时执行 fn 函数</p><p>想要达到这样一个目的, 就必须: getter 时能够收集当前的 fn 函数, 以便在 setter 时执行相应的 fn 函数</p><p>但是对于收集而言, 如果仅仅是吧 fn 存起来是不够的, 我们还需要知道, 当前的这个 fn 是哪个响应式数据对象的哪个属性对应的, 只有这样, 才可以在该属性触发 setter 时, 准确的执行响应性</p><ol><li>调用 reactive 方法</li></ol><div class="vp-code-group"><div class="tabs"><input type="radio" name="group-ZuRut" id="tab-hkl5SFn" checked="checked"><label for="tab-hkl5SFn">reactive</label><input type="radio" name="group-ZuRut" id="tab-CunkB3c"><label for="tab-CunkB3c">createReactiveObject</label></div><div class="blocks"><div class="language-js active"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-palenight"><code><span class="line"><span style="color:#89DDFF;font-style:italic;">export</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">reactive</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">target</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">object</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#82AAFF;">createReactiveObject</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">target</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">mutableHandlers</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">reactiveMap</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-palenight"><code><span class="line"><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">createReactiveObject</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">target</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">object</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">baseHandlers</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">ProxyHandler</span><span style="color:#89DDFF;">&lt;</span><span style="color:#FFCB6B;">any</span><span style="color:#89DDFF;">&gt;,</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">proxyMap</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">WeakMap</span><span style="color:#89DDFF;">&lt;</span><span style="color:#FFCB6B;">object</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">any</span><span style="color:#89DDFF;">&gt;)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;">  </span><span style="color:#676E95;font-style:italic;">// 如果该实例已经被代理，则直接读取即可</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#C792EA;">const</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">existingProxy</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">proxyMap</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">get</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">target</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;font-style:italic;">if</span><span style="color:#F07178;"> (</span><span style="color:#A6ACCD;">existingProxy</span><span style="color:#F07178;">) </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">existingProxy</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#89DDFF;">  </span><span style="color:#676E95;font-style:italic;">// 未被代理则生成 proxy 实例</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#C792EA;">const</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">proxy</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">new</span><span style="color:#F07178;"> </span><span style="color:#82AAFF;">Proxy</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">target</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">baseHandlers</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#89DDFF;">  </span><span style="color:#676E95;font-style:italic;">// 为 Reactive 增加标记</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#A6ACCD;">proxy</span><span style="color:#F07178;">[</span><span style="color:#A6ACCD;">ReactiveFlags</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">IS_REACTIVE</span><span style="color:#F07178;">] </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#FF9CAC;">true</span></span>
<span class="line"></span>
<span class="line"><span style="color:#89DDFF;">  </span><span style="color:#676E95;font-style:italic;">// 缓存代理对象</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#A6ACCD;">proxyMap</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">set</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">target</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">proxy</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">proxy</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div></div></div><p>WeakMap:</p><ol><li>key: 响应式对象</li><li>value : Map 对象 <ol><li>key : 响应式对象的指定属性</li><li>value : 指定对象的指定属性的 执行函数 fn</li></ol></li></ol><h2 id="笔记" tabindex="-1">笔记 <a class="header-anchor" href="#笔记" aria-hidden="true">#</a></h2><p>对于 reactive 的响应性函数而言, 我们知道它:</p><ol><li>是通过 proxy 的 setter 和 getter 来实现数据监听</li><li>需要配合 effect 函数进行使用</li><li>基于 WeakMap 完成的依赖收集和触发</li><li>可以存在一对多的依赖关系</li></ol><p>不足之处:</p><ol><li>reactive 只能对复杂数据类型进行使用</li><li>reactive 的响应性数据, 不可以进行解构</li></ol><p>因为 reactive 的不足, 所以 vue3 又为我们提供了 ref 函数构建响应性</p><h2 id="ref" tabindex="-1">ref <a class="header-anchor" href="#ref" aria-hidden="true">#</a></h2><ol><li><p>对于 ref 函数, 会返回 RefImpl 类型实例</p></li><li><p>在该实例中, 会根据传入的数据类型进行分开处理</p><ol><li>复杂数据类型: 转化为 reactive 返回的 proxy 实例</li><li>简单数据类型: 不做处理</li></ol></li><li><p>无论我们执行 <a href="http://obj.value.name" target="_blank" rel="noreferrer">obj.value.name</a> 还是 <a href="http://obj.value.name" target="_blank" rel="noreferrer">obj.value.name</a> = xxx 本质上都是触发了 get value</p></li><li><p>之所以会进行响应性是因为 obj.value 是一个 reactive 函数生成的 proxy</p></li><li><p>ref 函数本质上是生成了一个 RefImpl 类型的实例对象, 通过 get 和 set 标记处理了 value 函数</p></li><li><p>为什么 ref 类型的数据, 必须通过 .value 访问值呢?</p><ol><li>因为 ref 需要处理简单数据类型的响应性, 但是对于简单数据类型而言, 它无法通过 proxy 建立代理</li><li>所以 vue 通过 get value() 和 set value() 定义了两个属性函数, 通过主动触发这两个函数的形式进行依赖收集和依赖触发</li><li>所以必须通过 .value 来确保响应性</li></ol></li></ol>`,16),o=[p];function t(r,c,i,y,F,D){return l(),a("div",null,o)}const u=s(e,[["render",t]]);export{A as __pageData,u as default};
