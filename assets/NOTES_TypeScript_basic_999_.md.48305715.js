import{_ as i,c as l,o as e,a}from"./app.eb5321dd.js";const f=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[{"level":2,"title":"类型收窄","slug":"类型收窄","link":"#类型收窄","children":[]},{"level":2,"title":"复杂函数类型定义","slug":"复杂函数类型定义","link":"#复杂函数类型定义","children":[]},{"level":2,"title":"泛型","slug":"泛型","link":"#泛型","children":[]},{"level":2,"title":"对象类型","slug":"对象类型","link":"#对象类型","children":[]},{"level":2,"title":"编译项配置 tsconfig","slug":"编译项配置-tsconfig","link":"#编译项配置-tsconfig","children":[]},{"level":2,"title":"泛型","slug":"泛型-1","link":"#泛型-1","children":[]},{"level":2,"title":"条件类型","slug":"条件类型","link":"#条件类型","children":[]},{"level":2,"title":"类","slug":"类","link":"#类","children":[]}],"relativePath":"_NOTES/TypeScript/basic/999_.md","lastUpdated":1679013837000}'),t={name:"_NOTES/TypeScript/basic/999_.md"},p=a('<p>目录</p><ul><li><p>基础类型</p></li><li><p>联合类型(类型收窄、类型称述语法)</p></li><li><p>函数</p></li><li><p>接口</p></li><li><p>基础类型</p></li><li><p>数组 (还可以用数组泛型)</p></li><li><p>对象</p></li><li><p>联合类型 <code>|</code> (类型收窄的概念)</p></li><li><p>类型别名(类型复用)</p></li><li><p>any</p></li><li><p>函数类型</p></li><li><p>接口类型(分号, 和对象类型很类似, 但是可以通过 extends 扩展, 还会自动合并)</p></li><li><p>交叉类型 (&amp;)</p></li><li><p>断言(as 、&lt;&gt;xxx)</p></li><li><p>字面量类型</p></li><li><p>null undefined(striky 模式)</p></li><li><p>void</p></li></ul><h2 id="类型收窄" tabindex="-1">类型收窄 <a class="header-anchor" href="#类型收窄" aria-hidden="true">#</a></h2><p>联合类型的类型收窄</p><ul><li>typeof</li><li>真值收窄</li><li>相等收窄</li><li>in 语法下的</li><li>instanceof</li></ul><p>类型陈述语法, 参数(联合类型) is yy</p><p>函数参数对象解构类型怎么写?</p><h2 id="复杂函数类型定义" tabindex="-1">复杂函数类型定义 <a class="header-anchor" href="#复杂函数类型定义" aria-hidden="true">#</a></h2><ul><li>有属性的函数</li><li>构造函数</li><li>函数重载</li></ul><p>如何写 Date() 函数</p><h2 id="泛型" tabindex="-1">泛型 <a class="header-anchor" href="#泛型" aria-hidden="true">#</a></h2><p>函数和泛型</p><h2 id="对象类型" tabindex="-1">对象类型 <a class="header-anchor" href="#对象类型" aria-hidden="true">#</a></h2><p>主要是接口</p><ul><li>对象的属性重命名和解构语法要分清</li><li>interface 的 readonly 属性</li><li>如何给对象扩展属性</li><li>接口继承(多个)</li><li>接口合并</li><li>交叉类型</li></ul><h2 id="编译项配置-tsconfig" tabindex="-1">编译项配置 tsconfig <a class="header-anchor" href="#编译项配置-tsconfig" aria-hidden="true">#</a></h2><h2 id="泛型-1" tabindex="-1">泛型 <a class="header-anchor" href="#泛型-1" aria-hidden="true">#</a></h2><ul><li>泛型中使用 extends 和 keyof 语法</li></ul><h2 id="条件类型" tabindex="-1">条件类型 <a class="header-anchor" href="#条件类型" aria-hidden="true">#</a></h2><p>可以让函数重载更简便</p><h2 id="类" tabindex="-1">类 <a class="header-anchor" href="#类" aria-hidden="true">#</a></h2><p>private、protected、public 访问类型</p><ul><li>public : 允许在类的内外被调用</li><li>private : 允许在类内被使用</li><li>protected : 允许在类内及继承的子类中使用</li></ul><p>抽象类只能被继承, 不能实现。</p>',24),r=[p];function n(d,c,h,s,o,u){return e(),l("div",null,r)}const g=i(t,[["render",n]]);export{f as __pageData,g as default};
