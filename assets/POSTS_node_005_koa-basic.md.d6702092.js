import{_ as p,c,b as s,e,w as t,d as l,a,r as i,o as r}from"./app.e96f5412.js";const u="/mochi-blog/assets/001_koa-onion-model.154a136a.png",js=JSON.parse('{"title":"Koa 基础使用","titleTemplate":false,"description":"","frontmatter":{"date":"2023-01-16 08:20:10","title":"Koa 基础使用","titleTemplate":false,"author":"Mochi","outline":[2,4],"categories":["post"],"tags":["node","koa"]},"headers":[{"level":2,"title":"Koa 简介","slug":"koa-简介","link":"#koa-简介","children":[]},{"level":2,"title":"安装","slug":"安装","link":"#安装","children":[]},{"level":2,"title":"核心概念","slug":"核心概念","link":"#核心概念","children":[{"level":3,"title":"应用","slug":"应用","link":"#应用","children":[]},{"level":3,"title":"上下文","slug":"上下文","link":"#上下文","children":[]},{"level":3,"title":"请求","slug":"请求","link":"#请求","children":[]},{"level":3,"title":"响应","slug":"响应","link":"#响应","children":[]}]},{"level":2,"title":"路由","slug":"路由","link":"#路由","children":[]},{"level":2,"title":"错误处理","slug":"错误处理","link":"#错误处理","children":[]}],"relativePath":"_POSTS/node/005_koa-basic.md","lastUpdated":1673869884000}'),d={name:"_POSTS/node/005_koa-basic.md"},_=a(`<h1 id="koa-基础使用" tabindex="-1">Koa 基础使用 <a class="header-anchor" href="#koa-基础使用" aria-hidden="true">#</a></h1><p><a href="https://koa.bootcss.com/" target="_blank" rel="noreferrer">koa</a> -- 基于 Node.js 平台下一代 web 开发框架</p><h2 id="koa-简介" tabindex="-1">Koa 简介 <a class="header-anchor" href="#koa-简介" aria-hidden="true">#</a></h2><p>Koa 是一个新的 web 框架, 由 Express 幕后的原班人马打造。</p><p>通过利用 async 函数, Koa 丢弃了回调函数, 并有力地增强错误处理。Koa 并<strong>没有</strong>捆绑任何中间件, 而是提供了一套更优雅的方法编写服务端应用程序。</p><h2 id="安装" tabindex="-1">安装 <a class="header-anchor" href="#安装" aria-hidden="true">#</a></h2><p>Koa 依赖 node v7.6.0 或 ES2015 及更高版本和 async 方法支持。</p><div class="language-shell"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki material-palenight"><code><span class="line"><span style="color:#FFCB6B;">npm</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">install</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">koa</span></span>
<span class="line"></span></code></pre></div><h2 id="核心概念" tabindex="-1">核心概念 <a class="header-anchor" href="#核心概念" aria-hidden="true">#</a></h2><h3 id="应用" tabindex="-1">应用 <a class="header-anchor" href="#应用" aria-hidden="true">#</a></h3><p>Koa 应用程序是一个包含一组中间件函数的对象, 它是按照类似堆栈的方式组织执行的。</p><div class="vp-code-group"><div class="tabs"><input type="radio" name="group-0uRSx" id="tab-A9xutUy" checked="checked"><label for="tab-A9xutUy">Hello World</label></div><div class="blocks"><div class="language-js active"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-palenight"><code><span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> Koa </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">require</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">koa</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;">)</span></span>
<span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> app </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">Koa</span><span style="color:#A6ACCD;">()</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">app</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">use</span><span style="color:#A6ACCD;">(</span><span style="color:#C792EA;">async</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">ctx</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#A6ACCD;">ctx</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">body</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">Hello World</span><span style="color:#89DDFF;">&#39;</span></span>
<span class="line"><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;">)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">app</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">listen</span><span style="color:#A6ACCD;">(</span><span style="color:#F78C6C;">3000</span><span style="color:#A6ACCD;">)</span></span>
<span class="line"></span></code></pre></div></div></div>`,12),h={class:"details custom-block"},y=s("summary",null,"App API",-1),C=s("li",null,"app.callback() : 返回适用于 http.createServer() 方法的回调函数来处理请求",-1),A=s("li",null,"app.keys= : 设置签名的 Cookie 密钥",-1),D=s("h4",{id:"中间件函数",tabindex:"-1"},[l("中间件函数 "),s("a",{class:"header-anchor",href:"#中间件函数","aria-hidden":"true"},"#")],-1),x=a(`<div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-palenight"><code><span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> middleware </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">async</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">ctx</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">next</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;">  </span><span style="color:#676E95;font-style:italic;">// ...</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#82AAFF;">next</span><span style="color:#F07178;">()</span></span>
<span class="line"><span style="color:#89DDFF;">  </span><span style="color:#676E95;font-style:italic;">//...</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div><p>中间件函数可以执行以下任务：</p><ul><li>执行任何代码</li><li>对上下文进行修改</li><li>结束请求/响应循环</li><li>调用堆栈中的下一个中间件</li></ul><p>如果当前中间件函数没有结束请求/响应循环, 那么它必须调用 next(), 以将控制权传递给下一个中间件函数。否则, 请求将保持<strong>挂起</strong>状态。</p><h4 id="级联" tabindex="-1">级联 <a class="header-anchor" href="#级联" aria-hidden="true">#</a></h4><p><img src="`+u+`" alt="洋葱模型"></p><div class="info custom-block"><p class="custom-block-title">多个中间件会形成一个栈结构, 以&quot;先进后出&quot;的顺序执行:</p><ol><li>最外层的中间件首先执行</li><li>调用 next 函数, 把执行权交给下一个中间件</li><li>...</li><li>最内层的中间件最后执行</li><li>执行结束后, 把执行权交回上一层的中间件</li><li>...</li><li>最外层的中间件收回执行权后, 执行 next 函数后面的代码</li></ol></div><h3 id="上下文" tabindex="-1">上下文 <a class="header-anchor" href="#上下文" aria-hidden="true">#</a></h3><p>Koa Context 将 node 的 request 和 response 对象封装到单个对象中, 为编写 Web 应用程序和 API 提供了许多有用的方法。</p><div class="vp-code-group"><div class="tabs"><input type="radio" name="group-pELjW" id="tab-71wIBNF" checked="checked"><label for="tab-71wIBNF">koa context</label></div><div class="blocks"><div class="language-js active"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-palenight"><code><span class="line"><span style="color:#A6ACCD;">app</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">use</span><span style="color:#A6ACCD;">(</span><span style="color:#C792EA;">async</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">ctx</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#A6ACCD;">ctx</span><span style="color:#F07178;"> </span><span style="color:#676E95;font-style:italic;">// context</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#A6ACCD;">ctx</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">request</span><span style="color:#F07178;"> </span><span style="color:#676E95;font-style:italic;">// koa request</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#A6ACCD;">ctx</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">response</span><span style="color:#F07178;"> </span><span style="color:#676E95;font-style:italic;">// koa response</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#A6ACCD;">ctx</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">req</span><span style="color:#F07178;"> </span><span style="color:#676E95;font-style:italic;">// node request</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#A6ACCD;">ctx</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">res</span><span style="color:#F07178;"> </span><span style="color:#676E95;font-style:italic;">// node response</span></span>
<span class="line"><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;">)</span></span>
<span class="line"></span></code></pre></div></div></div>`,10),f={class:"details custom-block"},F=s("summary",null,"Context API",-1),g=s("li",null,"ctx.req : Node 的 request 对象",-1),m=s("li",null,"ctx.res : Node 的 response 对象, 绕过 Koa 的 resopnse 处理是不被支持的",-1),q=s("li",null,"ctx.state : 推荐的命名空间，用于通过中间件传递信息和前端视图",-1),k=s("li",null,"ctx.app : 应用实例",-1),b=s("li",null,"ctx.app.emit : 发送事件",-1),T=s("li",null,"ctx.cookies.get(name, [options]) : 通过 options 获取 cookie name",-1),v=s("li",null,"ctx.cookies.set(name, value, [options]) : 通过 options 设置 cookie name 的 value",-1),E=s("li",null,"ctx.assert(value, [status], [msg], [properties]) : 当 !value 时抛出一个类似 throw 错误的帮助方法",-1),S=s("li",null,"ctx.respond : 如果需要绕过 Koa 的内置 response 处理, 可以显式设置 ctx.respond = false",-1),R=s("p",null,[l("绕过 Koa 的 resopnse 处理是不被支持的。应 "),s("strong",null,"避免使用"),l(" 以下 node 属性：")],-1),P=s("ul",null,[s("li",null,"ctx.res.statusCode"),s("li",null,"ctx.res.writeHead()"),s("li",null,"ctx.res.write()"),s("li",null,"ctx.res.end()")],-1),I={class:"details custom-block"},K=s("summary",null,"Context 别名",-1),w=s("p",null,"Request 别名",-1),N=s("li",null,"ctx.header",-1),V=s("li",null,"ctx.method",-1),L=s("li",null,"ctx.method=",-1),j=s("li",null,"ctx.url",-1),U=s("li",null,"ctx.url=",-1),B=s("li",null,"ctx.originalUrl",-1),H=s("li",null,"ctx.origin",-1),W=s("li",null,"ctx.href",-1),M=s("li",null,"ctx.path",-1),O=s("li",null,"ctx.path=",-1),$=a("<li>ctx.query=</li><li>ctx.querystring</li><li>ctx.querystring=</li><li>ctx.host</li><li>ctx.hostname</li><li>ctx.fresh</li><li>ctx.stale</li><li>ctx.socket</li><li>ctx.protocol</li><li>ctx.secure</li><li>ctx.ip</li><li>ctx.ips</li><li>ctx.subdomains</li><li>ctx.is()</li><li>ctx.accepts()</li><li>ctx.acceptsEncodings()</li><li>ctx.acceptsCharsets()</li><li>ctx.acceptsLanguages()</li><li>ctx.get()</li>",19),G=s("p",null,"Response 别名",-1),J=s("li",null,"ctx.body",-1),z=s("li",null,"ctx.status",-1),Q=s("li",null,"ctx.message",-1),X=s("li",null,"ctx.length=",-1),Y=s("li",null,"ctx.length",-1),Z=s("li",null,"ctx.type=",-1),ss=s("li",null,"ctx.type",-1),ls=s("li",null,"ctx.headerSent",-1),es=s("li",null,"ctx.redirect()",-1),ts=s("li",null,"ctx.attachment()",-1),ns=s("li",null,"ctx.append()",-1),as=s("li",null,"ctx.remove()",-1),os=s("li",null,"ctx.lastModified=",-1),is=s("li",null,"ctx.etag=",-1),ps=s("p",null,[l("Request 和 Response 上属性或方法 ctx 大多都可 "),s("strong",null,"直接"),l(" 访问, 如 ctx.body。")],-1),cs=s("p",null,"但需要注意的是, 有关获取消息头的一般是请求头, 设置消息头的一般是响应头。如",-1),rs=s("ul",null,[s("li",null,"ctx.headers 指的是 request.headers"),s("li",null,"ctx.set() 指的是 response.set()")],-1),us=s("h3",{id:"请求",tabindex:"-1"},[l("请求 "),s("a",{class:"header-anchor",href:"#请求","aria-hidden":"true"},"#")],-1),ds=s("p",null,"Koa Request 对象是 node 原生请求对象之上的抽象, 提供了诸多对 HTTP 服务器开发有用的功能。",-1),_s={class:"details custom-block"},hs=s("summary",null,"Request API",-1),ys=s("li",null,"request.header : 请求头对象, request.headers 的别名",-1),Cs=a('<li>request.method : 请求方法</li><li>request.length : 请求的 Content-Length 或 undefined</li><li>request.url : 请求 URL</li><li>request.originalUrl : 请求原始 URL</li><li>request.origin : URL 来源, 包括 protocol 和 host</li><li>request.href : 完整的请求 URL, 包括 protocol、host 和 url</li><li>request.path : 请求路径名</li><li>request.querystring : 根据 &quot;?&quot; 获取的原始查询字符串</li><li>request.search : 同 request.querystring</li><li>request.host : 主机 (hostname:port)</li><li>request.hostname : 主机名</li><li>request.URL : WHATWG 解析的 URL 对象</li><li>request.type : 响应 Content-Type 的 mime-type, 如 image/png</li><li>request.charset : 请求字符集或 undefined</li><li>request.fresh : 检查请求缓存是否&quot;新鲜&quot;, 用于协商缓存</li><li>request.stale : 与 request.fresh 相反</li><li>request.protocol : 请求协议</li><li>request.secure : 通过 ctx.protocol == &quot;https&quot; 来检查请求是否通过 TLS 发出</li><li>request.ip : 请求远程地址</li><li>request.subdomains : 子域 (数组形式)</li><li><a href="http://request.is" target="_blank" rel="noreferrer">request.is</a>(types...) : 检查传入请求是否包含 Content-Type 消息头字段</li><li>request.accepts(types) : 检查给定的 type(s) 是否可以接受</li><li>request.acceptsEncodings(encodings) : 检查 encodings 是否可以接受</li><li>request.acceptsCharsets(charsets) : 检查 charsets 是否可以接受</li><li>request.acceptsLanguages(langs) : 检查 langs 是否可以接受</li><li>request.idempotent : 检查请求是否是幂等的</li><li>request.socket : 请求套接字</li><li>request.get(field) : 返回请求头 (header), field 不区分大小写</li>',28),As=s("h3",{id:"响应",tabindex:"-1"},[l("响应 "),s("a",{class:"header-anchor",href:"#响应","aria-hidden":"true"},"#")],-1),Ds=s("p",null,"Koa Response 对象是 node 原生响应对象之上的抽象, 提供了诸多对 HTTP 服务器开发有用的功能。",-1),xs={class:"details custom-block"},fs=s("summary",null,"Response API",-1),Fs=s("li",null,"response.header : response.headers 的别名",-1),gs=s("li",null,"response.message : 响应状态信息",-1),ms=s("li",null,"response.length : 响应的 Content-Length 或 undefined",-1),qs=s("ul",null,[s("li",null,"String : Content-Type 默认为 text/html 或 text/plain, 同时默认字符集是 utf-8"),s("li",null,"Buffer : Content-Type 默认为 application/octet-stream"),s("li",null,"Stream : Content-Type 默认为 application/octet-stream"),s("li",null,"Object : Content-Type 默认为 application/json")],-1),ks=s("li",null,"response.get(field) : 不区分大小写获取响应头字段值 field",-1),bs=s("li",null,"response.has(field) : 判断响应头是否含有字段值 field",-1),Ts=s("li",null,"response.set(field, value) : 设置响应头",-1),vs=s("li",null,"response.append(field, value) : 追加响应头",-1),Es=a("<li>response.remove(field) : 移除响应头</li><li>response.type : 响应 Content-Type 的 mime-type, 如 image/png</li><li>response.is(types...) : 检查响应类型是否是所提供的类型</li><li>response.redirect(url, [alt]) : 执行 [302] 重定向到 url</li><li>response.attachment([filename], [options]) : 将 Content-Disposition 设置为 &quot;附件&quot; 以指示客户端提示下载</li><li>response.headerSent : 检查是否已经发送了一个响应头, 用于查看客户端是否可能会收到错误通知</li><li>response.lastModified : Last-Modified 消息头</li><li>response.etag= : 设置 ETag</li><li>response.socket : 响应套接字</li><li>response.vary(field) : 设置 field 的 vary</li><li>response.flushHeaders() : 刷新任何设置的消息头，然后是主体(body)</li>",11),Ss=a('<h2 id="路由" tabindex="-1">路由 <a class="header-anchor" href="#路由" aria-hidden="true">#</a></h2><p>通过 ctx.request.path 可以获取用户请求的路径, 从而实现简单的路由。但是, 推荐使用 <a href="https://www.npmjs.com/package/@koa/router" target="_blank" rel="noreferrer">@koa/router</a> 中间件。</p><h2 id="错误处理" tabindex="-1">错误处理 <a class="header-anchor" href="#错误处理" aria-hidden="true">#</a></h2><p>全局错误处理可以通过 app.on(&#39;error&#39;, cb) 捕获, 如果是客户端错误可以使用 app.throw() 方法。</p>',4);function Rs(Ps,Is,Ks,ws,Ns,Vs){const n=i("f"),o=i("un");return r(),c("div",null,[_,s("details",h,[y,s("ul",null,[s("li",null,[e(n,null,{default:t(()=>[l("app.listen(...)")]),_:1}),l(" : 将 koa 应用程序绑定端口")]),s("li",null,[e(n,null,{default:t(()=>[l("app.use(function)")]),_:1}),l(" : 将中间件方法添加到应用程序, app.use() 返回 this, 可以链式调用")]),s("li",null,[e(n,null,{default:t(()=>[l("app.context")]),_:1}),l(" : 获取上下文")]),C,A,s("li",null,[e(n,null,{default:t(()=>[l("app.on('error', cb)")]),_:1}),l(" : 错误处理")])])]),D,s("p",null,[l("中间件函数能够访问"),e(o,null,{default:t(()=>[l("上下文(ctx)")]),_:1}),l("以及应用程序请求/响应循环中的"),e(o,null,{default:t(()=>[l("下一个中间件函数(next)")]),_:1}),l("。")]),x,s("details",f,[F,s("ul",null,[g,m,s("li",null,[e(n,null,{default:t(()=>[l("ctx.request")]),_:1}),l(" : koa 的 Request 对象")]),s("li",null,[e(n,null,{default:t(()=>[l("ctx.response")]),_:1}),l(" : koa 的 Response 对象")]),s("li",null,[e(n,null,{default:t(()=>[l("ctx.params")]),_:1}),l(" : 路由参数获取, 如 /:id")]),q,k,b,T,v,s("li",null,[e(n,null,{default:t(()=>[l("ctx.throw(\\[status], \\[msg], \\[properties])")]),_:1}),l(" : 抛出一个包含 status 属性错误的方法, status 默认值为 500")]),E,S])]),R,P,s("details",I,[K,s("ol",null,[s("li",null,[w,s("ul",null,[N,s("li",null,[e(n,null,{default:t(()=>[l("ctx.headers")]),_:1})]),V,L,j,U,B,H,W,M,O,s("li",null,[e(n,null,{default:t(()=>[l("ctx.query")]),_:1})]),$])]),s("li",null,[G,s("ul",null,[J,s("li",null,[e(n,null,{default:t(()=>[l("ctx.body=")]),_:1})]),z,s("li",null,[e(n,null,{default:t(()=>[l("ctx.status=")]),_:1})]),Q,s("li",null,[e(n,null,{default:t(()=>[l("ctx.message=")]),_:1})]),X,Y,Z,ss,ls,es,ts,s("li",null,[e(n,null,{default:t(()=>[l("ctx.set()")]),_:1})]),ns,as,os,is])])])]),ps,cs,rs,us,ds,s("details",_s,[hs,s("ul",null,[s("li",null,[e(n,null,{default:t(()=>[l("request.headers")]),_:1}),l(" : 请求头对象")]),ys,s("li",null,[e(n,null,{default:t(()=>[l("request.query")]),_:1}),l(" : ?分隔的查询字符串或空对象")]),Cs])]),As,Ds,s("details",xs,[fs,s("ul",null,[s("li",null,[e(n,null,{default:t(()=>[l("response.headers")]),_:1}),l(" : 响应头对象")]),Fs,s("li",null,[e(n,null,{default:t(()=>[l("response.status")]),_:1}),l(" : 响应状态, 没发送 body 默认 404")]),gs,ms,s("li",null,[e(n,null,{default:t(()=>[l("response.body")]),_:1}),l(" : 响应主体, 包含响应主体 response.status 默认 200"),qs]),ks,bs,Ts,vs,s("li",null,[e(n,null,{default:t(()=>[l("response.set(fields)")]),_:1}),l(" : 用一个对象设置多个响应头 fields")]),Es])]),Ss])}const Us=p(d,[["render",Rs]]);export{js as __pageData,Us as default};
