import{_ as i,c as e,o as l,a as t}from"./app.7f6c1fc1.js";const a="/mochi-blog/assets/001_http-status-302.b9aa88f8.png",T=JSON.parse('{"title":"HTTP 基础","titleTemplate":false,"description":"","frontmatter":{"date":"2023-02-05 08:41:08","title":"HTTP 基础","titleTemplate":false,"author":"Mochi","outline":[2,4],"categories":["post"],"tags":["http"]},"headers":[{"level":2,"title":"状态码","slug":"状态码","link":"#状态码","children":[{"level":3,"title":"状态码分类","slug":"状态码分类","link":"#状态码分类","children":[]},{"level":3,"title":"常见状态码","slug":"常见状态码","link":"#常见状态码","children":[]}]},{"level":2,"title":"请求方法","slug":"请求方法","link":"#请求方法","children":[]},{"level":2,"title":"头部信息","slug":"头部信息","link":"#头部信息","children":[{"level":3,"title":"请求头","slug":"请求头","link":"#请求头","children":[]},{"level":3,"title":"响应头","slug":"响应头","link":"#响应头","children":[]}]},{"level":2,"title":"HTTP 协议的瓶颈","slug":"http-协议的瓶颈","link":"#http-协议的瓶颈","children":[]}],"relativePath":"_POSTS/http/001_http.md","lastUpdated":1675606501000}'),n={name:"_POSTS/http/001_http.md"},h=t('<h1 id="http-基础" tabindex="-1">HTTP 基础 <a class="header-anchor" href="#http-基础" aria-hidden="true">#</a></h1><h2 id="状态码" tabindex="-1">状态码 <a class="header-anchor" href="#状态码" aria-hidden="true">#</a></h2><h3 id="状态码分类" tabindex="-1">状态码分类 <a class="header-anchor" href="#状态码分类" aria-hidden="true">#</a></h3><ul><li>1xx : 服务器收到请求</li><li>2xx : 请求成功, 如 200</li><li>3xx : 重定向, 如 302</li><li>4xx : 客户端错误</li><li>5xx : 服务端错误</li></ul><h3 id="常见状态码" tabindex="-1">常见状态码 <a class="header-anchor" href="#常见状态码" aria-hidden="true">#</a></h3><ul><li>200 : 成功</li><li>301 : 永久重定向(配合 Location 响应头, 浏览器自动处理)</li><li>302 : 临时重定向(配合 Location 响应头, 浏览器自动处理)</li><li>304 : 资源未修改, 协商缓存</li><li>404 : 资源未找到</li><li>403 : 没有权限</li><li>500 : 服务器错误</li><li>504 : 网关超时</li></ul><p>像百度一下搜索的跳转就是 302 临时重定向, 首先还是跳百度的地址, 返回状态码 302, 然后 Location 响应头是目标地址, 浏览器就会自动跳转。</p><p><img src="'+a+'" alt="302 状态码"></p><h2 id="请求方法" tabindex="-1">请求方法 <a class="header-anchor" href="#请求方法" aria-hidden="true">#</a></h2><ul><li>get : 获取数据</li><li>post : 新建数据</li><li>put : 更新数据</li><li>patch : 更新数据(部分更新)</li><li>delete : 删除数据</li></ul><p>接口设计应该遵从 <a href="https://restfulapi.cn/" target="_blank" rel="noreferrer">RESTful API</a> 规范。</p><h2 id="头部信息" tabindex="-1">头部信息 <a class="header-anchor" href="#头部信息" aria-hidden="true">#</a></h2><h3 id="请求头" tabindex="-1">请求头 <a class="header-anchor" href="#请求头" aria-hidden="true">#</a></h3><ul><li>Accept : 浏览器可接受的数据格式</li><li>Accept-Encoding : 浏览器可接收的压缩算法, 如 gzip</li><li>Accept-Language : 浏览器可接收的语言, 如 zh-CN</li><li>Content-Type : 发送的数据格式, 如 application/json</li><li>Connection : keep-alive 一次 TCP 连接重复使用</li><li>cookie : 默认同源请求会带上 cookie</li><li>User-Agent : 简称 UA, 浏览器信息</li></ul><h3 id="响应头" tabindex="-1">响应头 <a class="header-anchor" href="#响应头" aria-hidden="true">#</a></h3><ul><li>Content-Type : 返回的数据格式, 如 application/json</li><li>Content-Length : 返回数据的大小, 字节为单位</li><li>Content-Encoding : 返回数据的压缩算法, 如 gzip</li><li>Set-Cookie : 服务端设置 Cookie</li></ul><h2 id="http-协议的瓶颈" tabindex="-1">HTTP 协议的瓶颈 <a class="header-anchor" href="#http-协议的瓶颈" aria-hidden="true">#</a></h2><ul><li>一条连接上只可发送一个请求</li><li>请求只能从客户端开始, 客户端不可以接受除响应以外的指令</li><li>请求/响应头部不经压缩就发送</li><li>每次互相发送相同的头部造成的浪费较多</li><li>非强制压缩发送</li></ul>',18),r=[h];function d(c,o,s,p,u,_){return l(),e("div",null,r)}const f=i(n,[["render",d]]);export{T as __pageData,f as default};
